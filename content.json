{"meta":{"title":"bingh's blog","subtitle":"吾日三省吾身","description":"bingh","author":"bingh","url":"http://www.zixing.me"},"pages":[{"title":"about","date":"2017-04-12T06:39:47.000Z","updated":"2017-04-12T06:41:13.401Z","comments":true,"path":"about/index.html","permalink":"http://www.zixing.me/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-04-12T06:21:47.000Z","updated":"2017-04-12T06:24:09.512Z","comments":true,"path":"tags/index.html","permalink":"http://www.zixing.me/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-04-12T06:29:13.000Z","updated":"2017-04-12T06:33:44.212Z","comments":true,"path":"categories/index.html","permalink":"http://www.zixing.me/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring中注解配置的源码剖析","slug":"Spring中注解配置的源码剖析","date":"2017-07-25T16:00:00.000Z","updated":"2017-07-27T03:18:09.150Z","comments":true,"path":"2017/07/26/Spring中注解配置的源码剖析/","link":"","permalink":"http://www.zixing.me/2017/07/26/Spring中注解配置的源码剖析/","excerpt":"一、引入与概述在spring4.0时代，推荐使用注解配合JavaConfig的方式完成程序的配置，相应的XmlBeanFactory被废弃。Spring注解和JavaConfig配置方式成为Spring开发的主流方式，SpringBoot就是基于这两种方式实现的自动配置（SpringBoot的自动配置计划会写）。JavaConfig配置方式也是基于Spring注解实现的，所以今天先来赏析下Spring注解的实现。","text":"一、引入与概述在spring4.0时代，推荐使用注解配合JavaConfig的方式完成程序的配置，相应的XmlBeanFactory被废弃。Spring注解和JavaConfig配置方式成为Spring开发的主流方式，SpringBoot就是基于这两种方式实现的自动配置（SpringBoot的自动配置计划会写）。JavaConfig配置方式也是基于Spring注解实现的，所以今天先来赏析下Spring注解的实现。 《JAVA编程思想》中关于注解是这么描述的。 注解（元数据）为我们在代码中添加信息提供了一种形式化的方式，使我们在稍后的某些时刻非常方便的使用这些数据。注解在一定程度上将元数据和代码文件结合在一起。 注解可以认为是提供元数据的一种方式，元数据就是描述数据的数据。注解本身是不能进行逻辑处理的，需要相应的编写注解解析器。在Spring中，一个Bean要想被IOC容器更好的管理生命周期，处理依赖关系，首先自身得加入到Ioc容器。加入到容器后，可以添加Bean的后置处理器（BeanPostProcessor或BeanFactoryPostProcessor）作为注解解析器，解析相应的注解，Spring注解方式便可实现各种功能。那么纯注解的方式该怎么实现加入容器这至关重要的第一步呢？ 方案一： 指定路径，扫描全路径中，类被任何注解修饰的class文件，反射对象，加入容器。客户端程序员操作简单暴力，但无辜消耗时间空间。 方案二： 明确指定要加入容器被注解修饰的class,反射对象，加入容器。准确，恰当，细粒度控制，但对于客户端程序员来说，操作复杂，修改耦合。Spring是如何实现注解方式把bean加入容器的呢？其实Spring的实现，也是以上两种方式，而且是都实现了。但对方案一做了更好的控制优化，并且实现方案二作为方案一的补充。Spring对方案一做的优化：肯定路径扫描这种粗粒度的方式，但不能容忍以“任何注解修饰”这种条件把bean加入容器造成的资源浪费和可能给非Spring相关类、库造成的不可控。要识别注解修饰类是否应该被加入容器，可以对注解类型做注册、过滤。Spring针对注解类型做了过滤器（AnnotationTypeFilter）。并且对注册做了优化，并不需要每个注解类型都注册一个类型过滤器，虽然Java注解并不支持继承，但是可以通过注解组合的方式传递注解类型。通俗些就是，我可以通过注解找到元注解，通过元注解找到元注解的元注解…这样得到元注解的类型信息也是可以过滤器match得到的。Spring就定义了这么一个“元注解”– @Compent。这样@Compent和某级元注解是@Compent的注解，就会被AnnotationTypeFilter match。被这种注解修饰的类就会被注册到容器。关于注解的发现，Spring没有采用反射机制的Annotation API ，而是使用asm类库直接操作.class文件，不需要加载类。 总结 Spring使用扫描@Compent注解及其组合注解修饰类的方式配合AnnotationTypeFilter过滤器实现注解修饰类的加入容器问题。 通过注册相应BeanPostProcessor做为注解解析器。 也可以直接注册指定的class,反射对象，加载到容器。 二、demo代码：三个Annotation： MyAnno(没有被@Compent注解) MyCompentAnno(直接被@Compent注解) MyIndirectCompentAnno(间接被@Compent注解) 1234567891011121314package me.zixing.spring.ioc.annotation_application_context;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * Created by bingh on 2017/7/25. */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno &#123;&#125; 1234567891011121314151617package me.zixing.spring.ioc.annotation_application_context;import org.springframework.stereotype.Component;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * Created by bingh on 2017/7/26. */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Componentpublic @interface MyCompentAnno &#123;&#125; 12345678910111213141516package me.zixing.spring.ioc.annotation_application_context;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * Created by bingh on 2017/7/26. */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@MyCompentAnnopublic @interface MyIndirectCompentAnno &#123;&#125; 三个基本Bean : BeanA(被@MyAnno注解) BeanB(被@MyCompentAnno注解) BeanC(被@MyIndirectCompentAnno注解) BeanD(被@Compent注解) 1234567891011package me.zixing.spring.ioc.annotation_application_context;/** * Created by bingh on 2017/7/24. */@MyAnnopublic class BeanA &#123; public void show()&#123; System.out.println(\"BeanA\"); &#125;&#125; 123456789101112package me.zixing.spring.ioc.annotation_application_context;/** * Created by bingh on 2017/7/26. */@MyCompentAnnopublic class BeanB &#123; public void show()&#123; System.out.println(\"BeanB\"); &#125;&#125; 123456789101112package me.zixing.spring.ioc.annotation_application_context;/** * Created by bingh on 2017/7/26. */@MyIndirectCompentAnnopublic class BeanC &#123; public void show()&#123; System.out.println(\"BeanC\"); &#125;&#125; 12345678910111213package me.zixing.spring.ioc.annotation_application_context;import org.springframework.stereotype.Component;/** * Created by bingh on 2017/7/26. */@Componentpublic class BeanD &#123; public void show()&#123; System.out.println(\"BeanD\"); &#125;&#125; 测试类 TestAnnotationApplicationContext 12345678910111213141516171819202122package me.zixing.spring.ioc.annotation_application_context;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class TestAnnotationApplicationContext &#123; @Test public void test()&#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(\"me.zixing.spring.ioc.annotation_application_context\"); //! BeanA beanA = applicationContext.getBean(BeanA.class); BeanB beanB = applicationContext.getBean(BeanB.class); BeanC beanC = applicationContext.getBean(BeanC.class); BeanD beanD = applicationContext.getBean(BeanD.class); //! beanA.show(); beanB.show(); beanC.show(); beanD.show(); &#125;&#125; 结果： BeanB BeanC BeanD 结论： BeanA没有被加进容器，实现被注解类的过滤注册 BeanB被加入容器，元注解为@Compent的注解match BeanC被加入容器，某级元注解为@Compent的注解match BeanD被加入容器，注解@Compent match 三、源码解析： 从测试代码构造ApplicationContext入手 12ApplicationContext applicationContext = new AnnotationConfigApplicationContext(\"me.zixing.spring.ioc.annotation_application_context\"); 进去看构造函数 ↓↓↓↓ 1234567891011/** * Create a new AnnotationConfigApplicationContext, scanning for bean definitions * in the given packages and automatically refreshing the context. * @param basePackages the packages to check for annotated classes */public AnnotationConfigApplicationContext(String... basePackages) &#123; this();//设置reader和scanner scan(basePackages);//扫描给定包下的class,符合过滤条件的注册BeanDefinition到容器 refresh();//刷新：准备环境，创建、设置beanFactory&#125; 无参构造，设置reader和scanner,ranh123456789/** * Create a new AnnotationConfigApplicationContext that needs to be populated * through &#123;@link #register&#125; calls and then manually &#123;@linkplain #refresh refreshed&#125;. */public AnnotationConfigApplicationContext() &#123; this.reader = new AnnotatedBeanDefinitionReader(this); this.scanner = new ClassPathBeanDefinitionScanner(this);&#125; 关于refresh()方法不是这里的重点，但他是ApplicationContext的重点入口，只是这里不再多说。 scan()函数:扫描的入口函数，委托调用scanner的scan函数 123456789101112/** * Perform a scan within the specified base packages. * &lt;p&gt;Note that &#123;@link #refresh()&#125; must be called in order for the context * to fully process the new classes. * @param basePackages the packages to check for annotated classes * @see #register(Class...) * @see #refresh() */public void scan(String... basePackages) &#123; Assert.notEmpty(basePackages, \"At least one base package must be specified\"); this.scanner.scan(basePackages);&#125; scanner的scan函数重真正做事的是scanner的doScan函数 123456789101112131415161718/** * Perform a scan within the specified base packages. * @param basePackages the packages to check for annotated classes * @return number of beans registered */ public int scan(String... basePackages) &#123; int beanCountAtScanStart = this.registry.getBeanDefinitionCount(); doScan(basePackages);//扫描逻辑 // Register annotation config processors, if necessary. if (this.includeAnnotationConfig) &#123; AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); &#125; return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart); &#125; doScan 12345678910111213141516171819202122232425262728293031323334/** * Perform a scan within the specified base packages, * returning the registered bean definitions. * &lt;p&gt;This method does &lt;i&gt;not&lt;/i&gt; register an annotation config processor * but rather leaves this up to the caller. * @param basePackages the packages to check for annotated classes * @return set of beans registered if any for tooling registration purposes (never &#123;@code null&#125;) */ protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Assert.notEmpty(basePackages, \"At least one base package must be specified\"); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); for (String basePackage : basePackages) &#123; Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);//这是发现候选组件的逻辑入口函数 for (BeanDefinition candidate : candidates) &#123; ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) &#123; postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); &#125; if (candidate instanceof AnnotatedBeanDefinition) &#123; AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); &#125; if (checkCandidate(beanName, candidate)) &#123; BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); registerBeanDefinition(definitionHolder, this.registry); &#125; &#125; &#125; return beanDefinitions; &#125; findCandidateComponents() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Scan the class path for candidate components. * @param basePackage the package to check for annotated classes * @return a corresponding Set of autodetected bean definitions */ public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) &#123; //创建set容器盛放符合过滤条件的class生成的BeanDefinition Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;(); try &#123; //扫描路径补齐 String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + \"/\" + this.resourcePattern; //由路径生成资源 Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); //对每个资源文件进行遍历处理 for (Resource resource : resources) &#123; if (traceEnabled) &#123; logger.trace(\"Scanning \" + resource); &#125; //资源文件是否可读 if (resource.isReadable()) &#123; try &#123; //生成class的元数据Reader,使用asm库实现 //metadataReader里面含有class的元数据和注解的元数据，这里面又含有类的注解，属性的注解，方法的注解，元注解 MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); //match AnnotationType if (isCandidateComponent(metadataReader)) &#123; ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); //是具体的类(非abstract interface)，且不是内部类，就是要找的组件了 if (isCandidateComponent(sbd)) &#123; if (debugEnabled) &#123; logger.debug(\"Identified candidate component class: \" + resource); &#125; //加入set candidates.add(sbd); &#125; else &#123; if (debugEnabled) &#123; logger.debug(\"Ignored because not a concrete top-level class: \" + resource); &#125; &#125; &#125; else &#123; if (traceEnabled) &#123; logger.trace(\"Ignored because not matching any filter: \" + resource); &#125; &#125; &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException( \"Failed to read candidate component class: \" + resource, ex); &#125; &#125; else &#123; if (traceEnabled) &#123; logger.trace(\"Ignored because not readable: \" + resource); &#125; &#125; &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException(\"I/O failure during classpath scanning\", ex); &#125; return candidates; &#125; 判断组件有效 判断符合excludeFilters和includeFilters的filter match12345678910111213141516171819202122/** * Determine whether the given class does not match any exclude filter * and does match at least one include filter. * @param metadataReader the ASM ClassReader for the class * @return whether the class qualifies as a candidate component */ protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException &#123; //excludeFilters for (TypeFilter tf : this.excludeFilters) &#123; if (tf.match(metadataReader, this.metadataReaderFactory)) &#123; return false; &#125; &#125; //includeFilters for (TypeFilter tf : this.includeFilters) &#123; if (tf.match(metadataReader, this.metadataReaderFactory)) &#123; return isConditionMatch(metadataReader); &#125; &#125; return false; &#125; includeFilter里有AnnotationTypeFilter，我们看看实现 整个的match逻辑被父类match方法固定了，matchself ，matchsupclass,matchinterface这些方法由子类重写实现（模板方法模式） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; // This method optimizes avoiding unnecessary creation of ClassReaders // as well as visiting over those readers. if (matchSelf(metadataReader)) &#123; return true; &#125; ClassMetadata metadata = metadataReader.getClassMetadata(); if (matchClassName(metadata.getClassName())) &#123; return true; &#125; if (this.considerInherited) &#123; if (metadata.hasSuperClass()) &#123; // Optimization to avoid creating ClassReader for super class. Boolean superClassMatch = matchSuperClass(metadata.getSuperClassName()); if (superClassMatch != null) &#123; if (superClassMatch.booleanValue()) &#123; return true; &#125; &#125; else &#123; // Need to read super class to determine a match... try &#123; if (match(metadata.getSuperClassName(), metadataReaderFactory)) &#123; return true; &#125; &#125; catch (IOException ex) &#123; logger.debug(\"Could not read super class [\" + metadata.getSuperClassName() + \"] of type-filtered class [\" + metadata.getClassName() + \"]\"); &#125; &#125; &#125; &#125; if (this.considerInterfaces) &#123; for (String ifc : metadata.getInterfaceNames()) &#123; // Optimization to avoid creating ClassReader for super class Boolean interfaceMatch = matchInterface(ifc); if (interfaceMatch != null) &#123; if (interfaceMatch.booleanValue()) &#123; return true; &#125; &#125; else &#123; // Need to read interface to determine a match... try &#123; if (match(ifc, metadataReaderFactory)) &#123; return true; &#125; &#125; catch (IOException ex) &#123; logger.debug(\"Could not read interface [\" + ifc + \"] for type-filtered class [\" + metadata.getClassName() + \"]\"); &#125; &#125; &#125; &#125; return false; &#125; 我们现在不考虑其他情况，简单分析AnnotationTypeFilter的matchSelf方法 1234567 @Overrideprotected boolean matchSelf(MetadataReader metadataReader) &#123; AnnotationMetadata metadata = metadataReader.getAnnotationMetadata(); return metadata.hasAnnotation(this.annotationType.getName()) || (this.considerMetaAnnotations &amp;&amp; metadata.hasMetaAnnotation(this.annotationType.getName()));&#125; metadata.hasAnnotation()和metadata.hasMetaAnnotation 12345@Override public boolean hasAnnotation(String annotationType) &#123; return this.annotationSet.contains(annotationType); &#125; 1234567891011@Override public boolean hasMetaAnnotation(String metaAnnotationType) &#123; Collection&lt;Set&lt;String&gt;&gt; allMetaTypes = this.metaAnnotationMap.values(); for (Set&lt;String&gt; metaTypes : allMetaTypes) &#123; if (metaTypes.contains(metaAnnotationType)) &#123; return true; &#125; &#125; return false; &#125; 通过调试看看annotationSet和metaAnnotationMap都装了些什么 annotationSet存放的是直接注解这个类的注解 metaAnnotationMap存放的是Key:这个类的直接注解全路径名，value是个set，存放的是key 注解的各级元注解 代码意思很清晰，注解或各级元注解中是否包含this.annotationType.getName()[如果考虑元注解] 现在就来看看这个 this.annotationType","categories":[{"name":"Spring","slug":"Spring","permalink":"http://www.zixing.me/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.zixing.me/tags/Spring/"},{"name":"注解","slug":"注解","permalink":"http://www.zixing.me/tags/注解/"}]},{"title":"linux系统基础调优之关闭防火墙","slug":"Linux系统基础调优之关闭防火墙","date":"2017-05-13T04:00:12.000Z","updated":"2017-05-13T06:14:52.556Z","comments":true,"path":"2017/05/13/Linux系统基础调优之关闭防火墙/","link":"","permalink":"http://www.zixing.me/2017/05/13/Linux系统基础调优之关闭防火墙/","excerpt":"关闭防火墙","text":"关闭防火墙 关闭防火墙服务 查看防火墙服务状态 /etc/init.d/iptables status 关闭防火墙服务 /etc/init.d/iptables stop 关闭防火墙服务自启 查看防火墙自启 chkconfig –list | grep “iptables” 1iptables 0:off 1:off 2:on 3:on 4:on 5:on 6:off 关闭防火墙自启 chkconfig iptables off 再次查看防火墙自启 chkconfig –list | grep “iptables” 1iptables 0:off 1:off 2:off 3:off 4:off 5:off 6:off","categories":[{"name":"linux","slug":"linux","permalink":"http://www.zixing.me/categories/linux/"}],"tags":[{"name":"系统调优","slug":"系统调优","permalink":"http://www.zixing.me/tags/系统调优/"},{"name":"防火墙","slug":"防火墙","permalink":"http://www.zixing.me/tags/防火墙/"}]},{"title":"linux系统基础调优之修改系统字符集","slug":"Linux系统基础调优之修改系统字符集","date":"2017-05-13T04:00:12.000Z","updated":"2017-05-13T06:18:29.521Z","comments":true,"path":"2017/05/13/Linux系统基础调优之修改系统字符集/","link":"","permalink":"http://www.zixing.me/2017/05/13/Linux系统基础调优之修改系统字符集/","excerpt":"修改系统字符集","text":"修改系统字符集 查看字符集配置文件 cat /etc/sysconfig/i18n 12LANG=&quot;en_GB.UTF-8&quot;SYSFONT=&quot;latarcyrheb-sun16&quot; 修改字符集 备份 cp /etc/sysconfig/i18n /etc/sysconfig/i18n.ori 预修改 sed ‘s#en_GB#zh_CN#g’ /etc/sysconfig/i18n 12LANG=&quot;zh_CN.UTF-8&quot;SYSFONT=&quot;latarcyrheb-sun16&quot; 修改 sed -i ‘s#en_GB#zh_CN#g’ /etc/sysconfig/i18n 查看 grep “LANG” /etc/sysconfig/i18n 1LANG=&quot;zh_CN.UTF-8&quot; 查看系统变量 echo $LANG 1en_GB.UTF-8 发现修改并未生效 生效 source /etc/sysconfig/i18n 或 . /etc/sysconfig/i18n 再次查看系统变量 echo $LANG 1zh_CN.UTF-8 修改完成","categories":[{"name":"linux","slug":"linux","permalink":"http://www.zixing.me/categories/linux/"}],"tags":[{"name":"系统调优","slug":"系统调优","permalink":"http://www.zixing.me/tags/系统调优/"},{"name":"字符集","slug":"字符集","permalink":"http://www.zixing.me/tags/字符集/"}]},{"title":"linux系统基础调优之关闭selinux","slug":"Linux系统基础调优之关闭selinux","date":"2017-05-13T04:00:12.000Z","updated":"2017-05-13T06:17:50.085Z","comments":true,"path":"2017/05/13/Linux系统基础调优之关闭selinux/","link":"","permalink":"http://www.zixing.me/2017/05/13/Linux系统基础调优之关闭selinux/","excerpt":"关闭SeLinux","text":"关闭SeLinux 查看selinux配置: cat /etc/selinux/config 1234567891011# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - SELinux is fully disabled.SELINUX=enforcing# SELINUXTYPE= type of policy in use. Possible values are:# targeted - Only targeted network daemons are protected.# strict - Full SELinux protection.SELINUXTYPE=targeted sed替换命令修改selinux配置(也可以通过vim编辑): 1.备份 cp /etc/selinux/config /etc/selinux/config.ori 2.预修改 sed ‘s#SELINUX=enforcing#SELINUX=disabled#g’ /etc/selinux/config 12345678910# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - SELinux is fully disabled.SELINUX=disabled# SELINUXTYPE= type of policy in use. Possible values are:# targeted - Only targeted network daemons are protected.# strict - Full SELinux protection.SELINUXTYPE=targeted 3.看一眼无误，再真正修改文件(sed -i) sed -i ‘s#SELINUX=enforcing#SELINUX=disabled#g’ /etc/selinux/config 4.grep查看修改结果(或cat) grep “disabled” /etc/selinux/config 12# disabled - SELinux is fully disabled.SELINUX=disabled 生效修改了/etc/selinux/config 配置文件，需要重启才生效，linux服务器是不能轻易重启的，这里先用命令临时修改selinux的状态 5.查看selinux状态 getenforce 1Enforcing 6.设置selinux状态 setenforce 1usage: setenforce [ Enforcing | Permissive | 1 | 0 ] Enforcing = 1,Permissive = 0 setenforce 0 7.再次查看selinux状态 getenforce 1Permissive","categories":[{"name":"linux","slug":"linux","permalink":"http://www.zixing.me/categories/linux/"}],"tags":[{"name":"系统调优","slug":"系统调优","permalink":"http://www.zixing.me/tags/系统调优/"},{"name":"selinux","slug":"selinux","permalink":"http://www.zixing.me/tags/selinux/"}]},{"title":"linux系统基础调优之调整运行模式","slug":"Linux系统基础调优之调整运行模式","date":"2017-05-13T04:00:12.000Z","updated":"2017-05-13T06:18:12.009Z","comments":true,"path":"2017/05/13/Linux系统基础调优之调整运行模式/","link":"","permalink":"http://www.zixing.me/2017/05/13/Linux系统基础调优之调整运行模式/","excerpt":"调整运行级别","text":"调整运行级别 查看linux运行级别配置文件 cat /etc/inittab 1234567891011121314151617181920212223242526# inittab is only used by upstart for the default runlevel.## ADDING OTHER CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.## System initialization is started by /etc/init/rcS.conf## Individual runlevels are started by /etc/init/rc.conf## Ctrl-Alt-Delete is handled by /etc/init/control-alt-delete.conf## Terminal gettys are handled by /etc/init/tty.conf and /etc/init/serial.conf,# with configuration in /etc/sysconfig/init.## For information on how to write upstart event handlers, or how# upstart works, see init(5), init(8), and initctl(8).## Default runlevel. The runlevels used are:# 0 - halt (Do NOT set initdefault to this)# 1 - Single user mode# 2 - Multiuser, without NFS (The same as 3, if you do not have networking)# 3 - Full multiuser mode# 4 - unused# 5 - X11# 6 - reboot (Do NOT set initdefault to this)# id:3:initdefault: 一共 0~6 7 个运行级别。 通过修改配置文件最后一行id:3:initdefault修改下次重启的默认运行级别(重启生效，永久) 查看当前运行级别 runlevel 1N 3 切换运行级别(立即切换，一次生效) init 1 init 3 init 5","categories":[{"name":"linux","slug":"linux","permalink":"http://www.zixing.me/categories/linux/"}],"tags":[{"name":"系统调优","slug":"系统调优","permalink":"http://www.zixing.me/tags/系统调优/"},{"name":"运行模式","slug":"运行模式","permalink":"http://www.zixing.me/tags/运行模式/"}]},{"title":"test","slug":"test","date":"2017-04-14T14:03:49.000Z","updated":"2017-04-15T04:30:19.754Z","comments":true,"path":"2017/04/14/test/","link":"","permalink":"http://www.zixing.me/2017/04/14/test/","excerpt":"标题一级标题二级标题三级标题四级标题五级标题六级标题","text":"标题一级标题二级标题三级标题四级标题五级标题六级标题 列表无序列表 水果 苹果 红苹果 小苹果 海棠果 香蕉 蔬菜 白菜 萝卜 谷物 小麦 大豆 有序列表 今天 上午 下午 晚上 明天 后天 引用 小荷才露尖尖角，早有蜻蜓立上头。–《小池》 粗体和斜体这是粗体 这是斜体 插入链接我的博客 插入图片 分割线 上面是分割线 表格 姓名 性别 工资 李想 男 1w 秦凤琳 女 2w 代码块123456class Demo&#123; public static void main (String args)&#123; System.out.println(\"Hello MD\"); &#125;&#125;","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://www.zixing.me/tags/test/"}]}]}